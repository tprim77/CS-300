# CS-300
Project 1 and 2 for SNHU CS300

**What was the problem you were solving in the projects for this course?**

The main problem I had to solve in the projects was learning how efficient programs run and how to code them. I learned that depending on the program, there are many ways to create an alogorithm, such as hash tables or binary search trees. Each comes with its own strengths and weaknesses.

**How did you approach the problem? Consider why data structures are important to understand.**

I went in knowing what the program needed to do. It needed to be able to create a list of courses and then sort it and display any prerequisites for it. I went with a binary search tree because I believe it is the quickest way to sort, but other methods would have worked since the list of courses was relatively small.

**How did you overcome any roadblocks you encountered while going through the activities or project?**

I overcame most of my roadblocks by googling and searching through quite a bit of stackoverflow. My main issue in the project was reading files and I had to search for a little while before I found some reliable help with that. In the course we mainly used a CSV parser to read files, which I initially tried to use as well, but I was having too many issues with it so I chose to go a different route.

**How has your work on this project expanded your approach to designing software and developing programs?**

It made me realize there are many different ways to create programs, with some being better options than others. It is important to know what exactly the program needs to do in order to create any algorithms that can work well with it otherwise the code may be slower than is wanted.

**How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?**

I think my programs are still as maintainable and readable as they have always been because I try to organize things in a visually appealing way. I think I have increased my adaptability though because I now know more ways to create algorithms that can adapt to different programs that I will create in the future.
